{"pathnameRoot":"/cn/","authorUrl":"https://github.com/Terry-Su","locale":"zh_CN","logoTitle":"苏溪云","noteIsAutoTranslated":"本文为自动翻译。","copyright":{"left":"版权 © 2017-","center":"苏溪云","right":"保留所有权利"},"blogGithub":"https://github.com/Terry-Su/blogs-cn","id":"cn/http-cache","title":"轻松学会HTTP缓存（强缓存，协商缓存）","path":"Technology/Network","route":"/cn/http-cache","text":"\n\nconst layoutProps = {\n  \n};\nclass MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><MDXTag name=\"p\" components={components}>{`若读者对“强缓存”，“协商缓存”字眼非常熟悉，但又不知道他们具体是什么，亦或有读者还不了解HTTP缓存，那么本文将为读者一一讲解。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`HTTP缓存流程`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在介绍什么是强缓存、协商缓存前，让我们先了解HTTP缓存的流程，因为强缓存、协商缓存只是其中2步。`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/77868295-49009c80-726d-11ea-87a3-17a5bd0a657b.png\",\"alt\":\"image\"}}></MDXTag></MDXTag>\n<MDXTag name=\"h2\" components={components}>{`强缓存`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`“检查缓存是否过期”一步即强缓存。若缓存未过期，直接使用浏览器本地缓存，不用请求服务器。  `}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`检查缓存是否过期依据请求报文中的2种首部：过期时间`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Expires`}</MDXTag>{`和有效时间`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Cache-Control:max-age`}</MDXTag>{`。例子：`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"inlineCode\" components={components} parentName=\"li\">{`Expires: Fri, 05, Jul, 2020, 05:00:00 GMT`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"inlineCode\" components={components} parentName=\"li\">{`Cache-Control: max-age=60000`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`前者为缓存具体的过期时间，后者为缓存有效期。`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Cache-Control: max-age`}</MDXTag>{`的优先级高于`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Expires`}</MDXTag>{`。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`协商缓存`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`“协商缓存”可以理解为一个动作：“与服务器协商是否更新缓存”。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`当检查到缓存已过期，缓存端需要与服务器协商是否更新缓存。在请求报文中，用于协商的条件类首部也有2种，时间再验证`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`If-Modified-Since`}</MDXTag>{`和实体标签再验证`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`If-No-Matched`}</MDXTag>{`。若条件为真，服务器会返回新文档给缓存。否则，服务器返回304(Not Modified)。它们的格式为:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"inlineCode\" components={components} parentName=\"li\">{`If-Modified-Since: <date>`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"inlineCode\" components={components} parentName=\"li\">{`If-None-Matched: <tags>`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`日期再验证`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`If-Modified-Since`}</MDXTag>{`从字面即可理解：如何从某个时间之后文档被修改过。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`实体标签再验证`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`If-None-Matched`}</MDXTag>{`同样可理解为：若缓存端的实体标签Etag(Entity Tag)与服务器不匹配。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`实体标签是什么？ 这里要从既然有了日期再验证为何还需要实体标签验证说起。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`考虑一种特殊情况，若验证时，发现服务器上的文档被重写过文件修改时间，但内容不变，那这个时候日期再验证不通过，但实际并没有必要更新文档。所以引入了实体标签验证。实体标签Etag是为文档提供的特殊标签，格式为字符串，可看作唯一id。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`若实体标签再验证不通过，服务器会返回新文档和新的Etag给缓存。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`实体标签再验证的优先级高于日期再验证。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`客户端刷新和重载`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`那么客户端的刷新和重载如何影响HTTP缓存？事实上，每个浏览器都由自己的一套处理机制。一般来说，普通刷新不会影响缓存，但强制刷新（重载）会让缓存失效，重新向请求服务器文档。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`实践`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`光有理论没有实践验证肯定不够。此处使用一个案例体验协商缓存。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`新建一个文件夹，新建index.html, 内容为“Test Cache”。使用`}<MDXTag name=\"a\" components={components} parentName=\"p\" props={{\"href\":\"https://github.com/zeit/serve\"}}>{`serve`}</MDXTag>{`将该文件夹静态服务化。打开Chrome，新建标签页，打开开发人员工具，切换到网络模块，然后打开服务化后的地址: `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`http://localhost:5000`}</MDXTag>{`。`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/77868100-79940680-726c-11ea-9b68-383c08747230.png\",\"alt\":\"image\"}}></MDXTag>{`\n可看到服务返回状态为200。\n接下来刷新页面。\n`}<MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/77868125-8a447c80-726c-11ea-89ce-a30c89b5e561.png\",\"alt\":\"image\"}}></MDXTag>{`\n服务器返回状态变为304(Not Modified)。\n`}<MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/77868143-a0ead380-726c-11ea-8d5c-2e28e3cd1aec.png\",\"alt\":\"image\"}}></MDXTag>{`\n请求首部用的是实体标签再验证`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`If-None-Match:<tag>`}</MDXTag>{`。\n`}<MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/77868154-b233e000-726c-11ea-9e82-f85bc2590f78.png\",\"alt\":\"image\"}}></MDXTag>{`\n响应首部返回的Etag与请求中的Etag相同。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`总结`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`HTTP缓存的2个要点就是：\n1. 检查缓存是否过期（强缓存）\n2. 若缓存过期，与服务器协商是否更新缓存（协商缓存）。  `}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`而这2点每个都包含相关的2个报文请求首部：`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`强缓存：过期时间`}<MDXTag name=\"inlineCode\" components={components} parentName=\"li\">{`Expires`}</MDXTag>{` 和有效期`}<MDXTag name=\"inlineCode\" components={components} parentName=\"li\">{`Cache-Control: max-age`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`协商缓存：日期再验证`}<MDXTag name=\"inlineCode\" components={components} parentName=\"li\">{`If-Modified-Since`}</MDXTag>{`和实体标签再验证`}<MDXTag name=\"inlineCode\" components={components} parentName=\"li\">{`If-Not-Matched`}</MDXTag></MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`参考资料`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`《HTTP权威指南》 > 第7章 > 缓存`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://www.jianshu.com/p/f6525b0f8813\"}}>{`强缓存和协商缓存区别和过程`}</MDXTag></MDXTag>\n</MDXTag>\n           </MDXTag>\n  }\n}\nMDXContent.isMDXComponent = true\nrender( <MDXContent /> )\n  ","postTime":1585531800000,"comment":8,"isAutoTranslated":false,"availableOtherLocales":[],"importedCodes":"","siteTitle":"轻松学会HTTP缓存（强缓存，协商缓存）(苏溪云的博客)","siteMetaDescription":" 轻松学会HTTP缓存（强缓存，协商缓存） 若读者对“强缓存”，“协商缓存”字眼非常熟悉，但又不知道他们具体是什么，亦或有读者还不了解HTTP缓存，那么本文将为读者一一讲解。\n\nHTTP缓存流程\n在介绍什么是强缓存、协商缓存前，让我们先了解HT... (苏溪云的博客)","categoryTitle":"分类","postTimeTitle":"发布时间","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","endingWords":"article.endingWords","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","remarkDisqusComment":"https://terrysu.disqus.com/embed.js","texts":{"siteTitle":"苏溪云的博客","siteMetaDescription":"苏溪云的原创前端技术博客 4年前端 分享主流前端技术 JavaScript ReactJS","categoryNewest":"最近发布","navArticles":"所有文章","navAbout":"关于作者"},"articleTexts":{"endingWordsExtra":"**感谢你的阅读。欢迎通过微信（扫描下方二维码）或[Github](https://github.com/Terry-Su/blogs-cn)订阅我的博客。**\n\n ![微信公众号:苏溪云的博客](https://user-images.githubusercontent.com/23733477/77869172-2459f400-7270-11ea-8a84-d5d63a426c19.png)","qrcodeImageUrl":"","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","category":"分类","postTime":"发布时间","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","commentOnGithub":"添加评论 (by Github Issues)"},"markedEndingWordsExtra":"<p><strong>感谢你的阅读。欢迎通过微信（扫描下方二维码）或<a href=\"https://github.com/Terry-Su/blogs-cn\">Github</a>订阅我的博客。</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/23733477/77869172-2459f400-7270-11ea-8a84-d5d63a426c19.png\" alt=\"微信公众号:苏溪云的博客\" /></p>"}
