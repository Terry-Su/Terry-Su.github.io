{"pathnameRoot":"/cn/","authorUrl":"https://github.com/Terry-Su","locale":"zh_CN","logoTitle":"苏溪云","noteIsAutoTranslated":"本文为自动翻译。","copyright":{"left":"版权 © 2017-","center":"苏溪云","right":"保留所有权利"},"blogGithub":"https://github.com/Terry-Su/blogs-cn","id":"cn/the-tour-of-travelling-webpack-internals","title":"看完Webpack源码，我学到了这些","path":"Technology/FrontEnd/Webpack","route":"/cn/the-tour-of-travelling-webpack-internals","text":"\n\nconst layoutProps = {\n  \n};\nclass MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><MDXTag name=\"p\" components={components}><MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/72396026-56ca7980-3776-11ea-8711-abf38176d1fe.png\",\"alt\":null}}></MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`继React,Vue，这是第三个着重阅读源码的前端项目-Webpack。本文主要以：  `}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`WHY: 为何要看Webpack源码`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`HOW: 如何阅读Webpack源码   `}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`WHAT: 看完源码后学到了什么 `}</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`三个方向展开。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`WHY`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`诚然Webpack这是一个前端工程化工具，理解容易， 使用简单，似乎没有深入研究的必要。那为什么还要费心费力阅读其源码？这，把正在写此篇文章的我也问住了。理提纲时，认为WHY最好写，几句话就可带过，但事实证明真要较真这一块还值得一说。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`擅自揣测下会阅读Webpack源码伙伴可能的动机：`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`1. 丰富工作经验`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`2. 技术真爱粉，知其然亦须知其所以然，同时学习方法`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`3. 与工作或个人项目相关，参考学习`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`4. 看有人写相关文章，也看看了解下      `}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`作者最先是原因是4，然后是1，2。当然，1，2应该是大多数人看项目源码的动机。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`How`}</MDXTag>\n<MDXTag name=\"h3\" components={components}>{`搭建源码调试环境`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`要阅读源码，首先拿到源码，然后最后能边调试边阅读。当然，如果智力和推理能力惊人，大可以直接在Github上在线阅读。\n有2中方法下载源码。一种是最常见的git clone,将Github上webpack项目clone到本地，pull后与webpack官方最新代码保持一致，一劳永逸。不过作者尝试第一种方法时，总是clone不下来，很大可能是由于webpack源文件过大且github服务器clone一直很慢。\n于是退而求其次，使用第二种方法：下载Webpack源码release版本。选择一个打算阅读的webpack源码版本，直接下载\"Source code(zip)\"即可。速度非常快，因为不包含.git。\n`}<MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/72396287-2a632d00-3777-11ea-9aa8-7ba669a1869a.png\",\"alt\":\"image\"}}></MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`IDE作者使用VSCode,调试node很方便。拿到源码后，在目录新建一个文件夹，写一个简单的webpack案例，然后使用VSCode进行调试。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`不过，在实际操作中，直接使用下载源码中的webpack.js调试可能会出现报错`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Cannot find module 'json-parse-better-errors'`}</MDXTag>{`或`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`Cannot find module 'webpack/lib/RequestShortener'`}</MDXTag>{`，只需运行`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`npm install webpack webpack-cli --save-dev`}</MDXTag>{`，即可解决报错，且不影响调试源码。`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/72396313-42d34780-3777-11ea-9216-a5b60904a2e0.png\",\"alt\":\"image\"}}></MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`此附作者在调试时`}<MDXTag name=\"a\" components={components} parentName=\"p\" props={{\"href\":\"https://github.com/Terry-Su/learn-webpack/archive/0.0.1.zip\"}}>{`使用版本`}</MDXTag>{`参考，下载后使用VSCode打开webpack-4.41.4(modified)，安装依赖，安装webpack和webpack-cli，按F5即可启动调试。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`调试，理清大致脉路走向`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`Webpack源码量庞大，把每一行代码都读懂确实没有必要，但是我们至少要知道它的整体运行流程，知道它反复用到的核心代码，以及各个模块的生命周期如何运转。`}</MDXTag>\n<MDXTag name=\"h3\" components={components}>{`找核心功能源码`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`代码量大，想要在走整体流程时恰好找核心功能的源码，困难重重，至少对于webpack源码是这样，因为其独特的插件和回调结构。\n不过，我们可以根据每一个想要了解的核心功能，单独去寻找和阅读相关源码。比如，如果我们想看webpack如何打包生成bundle.js，可通过webpack一定会调用NodeJS文件系统输出文件方法，全局搜索\"writeFile\"找到相关代码，或通过bundle.js中的关键字\"// Check if module is in cache\"进行搜索。`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/72396333-51b9fa00-3777-11ea-9b46-509e137da8af.png\",\"alt\":\"image\"}}></MDXTag></MDXTag>\n<MDXTag name=\"h2\" components={components}>{`What`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`通过边调试边阅读代码，了解代码整体走向以及webpack如何打包生成bundle.js，作者学到了以下内容：`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`tapable插件机制`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`简化版Webpack运行流程`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`bundle.js内容如何生成`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"h3\" components={components}>{`Tapable`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"a\" components={components} parentName=\"p\" props={{\"href\":\"https://github.com/webpack/tapable\"}}>{`Tapable`}</MDXTag>{`在源码中应用随处可见，要了解源码，首先得学习tapable机制。其实它并不复杂，并且我们只需要知道它的基本作用和用法即可。\nTapable 可理解为一套钩子回调函数机制，每一个钩子可订阅多个函数，发布钩子时会运行该钩子订阅该的多个函数。\n用一个简单案例说明。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`const { SyncHook } = require('tapable')\nclass Car {\n    constructor() {\n        this.hooks = {\n           // # 添加一个钩子\n            start: new SyncHook()\n        }\n    }\n}\nconst car = new Car()\n// start钩子订阅一个函数\ncar.hooks.start.tap( 'run slowly', () => console.log('start running slowly')  )\n// start钩子订阅另一个函数\ncar.hooks.start.tap( 'run mediumly', () => console.log('start running mediumly') )\n\n// 发布钩子\ncar.hooks.start.call()   // 输出: run slowly  run mediumly\n`}</MDXTag></MDXTag>\n<MDXTag name=\"h3\" components={components}>{`简化版Webpack运行流程`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://user-images.githubusercontent.com/23733477/72341656-b89ecb00-3705-11ea-8bd8-7e7232333f3d.png\",\"alt\":\"4\"}}></MDXTag></MDXTag>\n<MDXTag name=\"h3\" components={components}>{`bundle.js内容如何生成`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`未压缩的bundle.js文件结构一般如下：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`/******/ (function(modules) { // webpackBootstrap\n/******/    // The module cache\n/******/    var installedModules = {};\n/******/\n/******/    // The require function\n/******/    function __webpack_require__(moduleId) {\n/******/\n/******/        // Check if module is in cache\n/******/        if(installedModules[moduleId]) {\n/******/            return installedModules[moduleId].exports;\n/******/        }\n/******/        // Create a new module (and put it into the cache)\n/******/        var module = installedModules[moduleId] = {\n/******/            i: moduleId,\n/******/            l: false,\n/******/            exports: {}\n/******/        };\n....\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`那么Webpack如何生成这些内容？\n其实Webpack对于内容分两步处理，第一步先通过loader（默认为babel-loader）生成组合JS代码。第二步将组合JS代码放入webpack默认函数中，从而避免变量泄露。\n如打包前：`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`foo.js`}</MDXTag>{`  `}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`export const foo = () => 'hello foo!'\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`bar.js`}</MDXTag>{` `}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`import { foo } from './foo.js'\nfoo()\nconsole.log( 'hello bar!' )\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`打包第一步，通过loader（默认为babel-loader）生成组合JS代码：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`...\nconst foo = () => 'hello foo!'\n...\n\\\\r\\\\n__WEBPACK_MODULE_REFERENCE__0_666f6f_call__()\\\\r\\\\nconsole.log( 'hello bar!' )\n...\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`打包第二步，组合JS代码放入webpack默认函数中。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`/******/ (function(modules) { // webpackBootstrap\\\\n\n...\nconst foo = () => 'hello foo!'\n...\nfoo()\nconsole.log( 'hello bar!' )\n...\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`值得注意的是，核心文件为`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`ConcatenatedModule.js`}</MDXTag>{`, 通过遍历`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`modulesWithInfo`}</MDXTag>{`从而生成打包代码。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`常见问题`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\"><MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`runtime`}</MDXTag>{`是什么？`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`不管在webpack源码，还是Vue源码和其他地方，runtime经常出现。runtime究竟是什么？\n经过反复查阅资料和推敲，runtime代码可以理解为编译后生成的代码。比如，对于React，runtime代码就是编译JSX代码后生成的JS代码。对于Vue，runtime代码则是编译template,script,style后生成的JS代码。`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`热更新，Code Splitting, Tree-shaking等是如何实现?`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`Webpack内容较多，核心模块原理也不少，比如loader如何运转，Code Splitting如何实现，Tree-Shaking和热加载又是怎么做到的。但毕竟时间有限，此次阅读源码的目标不是大而全的弄懂所有内容，而是掌握Webpack的主要运转流程以及了解较为感兴趣的几个模块。所以其他模块原理以后有机再加入此文。对相应模块模块感兴趣的伙伴可网上先自行搜索相关内容。`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`阅读源码资源推荐`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://raw.githubusercontent.com/sokra/slides/master/data/how-webpack-works.pdf\"}}>{`how-react-works.pdf`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://webpack.wuhaolin.cn/\"}}>{`深入浅出webpack-吴浩麟`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://github.com/TheLarkInn/artsy-webpack-tour\"}}>{`help developers better understand how webpack works: artsy-webpack-tour`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://www.youtube.com/watch?v=Gc9-7PBqOC8\"}}>{`build your own webpack`}</MDXTag></MDXTag>\n</MDXTag>\n           </MDXTag>\n  }\n}\nMDXContent.isMDXComponent = true\nrender( <MDXContent /> )\n  ","postTime":1579050540000,"comment":8,"isAutoTranslated":false,"availableOtherLocales":[],"importedCodes":"","siteTitle":"看完Webpack源码，我学到了这些(苏溪云的博客)","siteMetaDescription":" 看完Webpack源码，我学到了这些 \n\n继React,Vue，这是第三个着重阅读源码的前端项目-Webpack。本文主要以： \n\n WHY: 为何要看Webpack源码\n HOW: 如何阅读Webpack源码 \n WHAT: 看完源码后... (苏溪云的博客)","categoryTitle":"分类","postTimeTitle":"发布时间","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","endingWords":"article.endingWords","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","remarkDisqusComment":"https://terrysu.disqus.com/embed.js","texts":{"siteTitle":"苏溪云的博客","siteMetaDescription":"苏溪云的原创前端技术博客 4年前端 分享主流前端技术 JavaScript ReactJS","categoryNewest":"最新文章","navArticles":"所有文章","navAbout":"关于作者"},"articleTexts":{"endingWordsExtra":"**欢迎[Star和订阅](https://github.com/Terry-Su/blogs-cn)，第一时间阅读我的最新原创前端技术博客。**","qrcodeImageUrl":"","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","category":"分类","postTime":"发布时间","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","commentOnGithub":"添加评论 (by Github Issues)"},"markedEndingWordsExtra":"<p><strong>欢迎<a href=\"https://github.com/Terry-Su/blogs-cn\">Star和订阅</a>，第一时间阅读我的最新原创前端技术博客。</strong></p>"}
