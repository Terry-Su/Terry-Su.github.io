{"pathnameRoot":"/cn/","authorUrl":"https://github.com/Terry-Su","locale":"zh_CN","logoTitle":"苏溪云","noteIsAutoTranslated":"本文为自动翻译。","copyright":{"left":"版权 © 2017-","center":"苏溪云","right":"保留所有权利"},"blogGithub":"https://github.com/Terry-Su/blogs-cn","id":"cn/understand-and-make-the-debounce","title":"防抖-理解，实践并实现","path":"Technology/FrontEnd/JavaScript","route":"/cn/understand-and-make-the-debounce","text":"\n\nconst layoutProps = {\n  \n};\nclass MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><MDXTag name=\"p\" components={components}>{`防抖（去抖），以及节流（分流）在日常开发中可能用的不多，但在特定场景，却十分有用。本文主要讨论防抖，镜像文章：`}<MDXTag name=\"a\" components={components} parentName=\"p\" props={{\"href\":\"https://terry-su.github.io/cn/understand-and-make-the-throttle\"}}>{`节流 - 理解，实践与实现`}</MDXTag>{`。分开讨论防抖和节流，主要是为了让一些还不太了解防抖节流的读者能够有针对性地，逐一掌握它们。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`防抖有`}<MDXTag name=\"strong\" components={components} parentName=\"p\">{`两种模式`}</MDXTag>{`（容易让人迷惑）：延时执行和直接执行。后续详细讨论。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`防抖还有一个关键点是如果用代码实现。本文以循序渐进地方式，先以实现一个简单案例为例，绘制流程图，再根据流程图逻辑编写防抖功能代码。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`典型案例`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`以日常开发中常用的搜索按钮为例，若用户点击一次搜索按钮后，不小心“手抖”很快又点了一次按钮，防抖可以规避第二次甚至更多次搜索。`}</MDXTag>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/debounce/search/index.html?mode=result\" ></iframe>\n<MDXTag name=\"p\" components={components}>{`第一个搜索按钮未做任何防抖处理。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`搜索按钮A为第一种防抖模式：延时执行。若用户连续快速点击多次，只有最后一次点击结束，延时一段时间后才执行搜索。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`搜索按钮B为第二种防抖模式：直接执行。若用户连续快速点击多次，只有第一次点击会执行搜索。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`防抖\b是什么`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`结合上方案例，防抖可以理解为：多次触发事件后，事件处理函数只执行一次。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`而防抖的两种模式可以根据实际使用场景分别应用。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`应用场景`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在搜索框中实时键入文本搜索`}</MDXTag>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/debounce/realtime-search/index.html?mode=result\" ></iframe>\n<MDXTag name=\"p\" components={components}>{`防止频繁点击搜索按钮触发搜索请求`}</MDXTag>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/debounce/standard-search/index.html?mode=result\" ></iframe>\n<MDXTag name=\"h2\" components={components}>{`一步步手写防抖`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`接下来我们通过一个案例梳理实现防抖的思路。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`假设我们要实现本文第一个案例中搜索按钮A的功能。首先整理需求：\n1. 点击搜索按钮后，函数并不马上执行，而是等一段时间再执行。\n2. 若在这段时间内，按钮再次被点击，则重新开始计时，等待同样一段时间后再执行。 `}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`实现的方法有两种，推荐第一种，用计时器(setTimeout)简化代码，将重心放在实现防抖的逻辑上。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`方法一核心参数：\n1. 等待时长\n2. 计时器`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`绘制方法一的流程图：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`graph TB\n开始--> A{计时器是否为空}\nA--> |是| B(添加计时器: 过了 等待时长 后, 执行搜索,然后 清除计时器)\nA--> |否| C(清除计时器)\nC--> B\nB--> 结束\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`根据流程图思路实现方法一的防抖代码：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`function debounce( func, wait = 0 ) {\n  let timer\n  \n  function debounced( ...args ) {\n    const self = this\n    if ( timer == null ) {\n      addTimer()\n      return\n    }\n\n    if ( timer != null ) {\n      clearTimer()\n      addTimer()\n      return\n    }\n\n    function addTimer() {\n      timer = setTimeout( () => {\n        invokeFunc()\n        clearTimer()\n      }, wait )\n    }\n\n    function invokeFunc() {\n      func.apply( self, args )\n    }\n  }\n\n  return debounced\n\n  function clearTimer() {\n    clearTimeout( timer )\n    timer = null\n  }\n}\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`方法二核心参数：\n1. 等待时长\n2. 最早可执行时间`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`绘制方法二的流程图：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`graph TB\n开始 --> IF1{最早可执行时间 是否定义}\nIF1 --> |是| IF2{当前时间 是否 大于或等于 最早可执行时间}\nIF1 --> |否| A(设置 最早可执行时间 为 当前时间 加上 等待时长)\nIF2 --> |是| B(执行搜索)\nIF2 --> |否| A\n\nB --> 结束\nA --> 结束\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`根据流程图实现方法二的防抖代码：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`function debounce( func, wait = 0 ) {\n  // Earliest time when func can be invoked\n  let earliest\n  \n  function debounced( ...args ) {\n    const self = this\n    \n    if ( typeof earliest === 'undefined' ) {\n      setEarliset()\n    }\n\n    if ( typeof earliest !== 'undefined' ) {\n      if ( now() >= earliest ) {\n        invokeFun()\n      } else {\n        setEarliset()\n      }\n    }\n\n    function setEarliset() {\n      earliest = now() + wait\n    }\n\n    function invokeFun() {\n      func.apply( self, args )\n    }\n  }\n\n  return debounced\n\n  function now() {\n    return +new Date()\n  }\n}\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`同样，我们可以使用类似方法实现搜索按钮B的功能。\n需求描述：\n1. 点击搜索按钮后，函数马上执行。只有等待一段时间后被点击才能执行函数。\n2. 若在这段时间内按钮被点击，则重新计时。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`核心参数：\n1. 等待时长\n2. 计时器`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`graph TB\n开始--> IF1{计时器是否为空}\nIF1 --> |是| B(执行搜索)\nB--> C(添加计时器: 过了 等待时长 后, 清除计时器)\n\n\nIF1 --> |否|D(清除计时器)\nD--> C\n\nC--> 结束\n`}</MDXTag></MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`function debounce( func, wait = 0 ) {\n  let timer\n  \n  function debounced( ...args ) {\n    const self = this\n\n    timer == null && invokeFunc()\n\n    timer != null && clearTimer()\n    \n    timer = setTimeout( clearTimer, wait )\n\n    function invokeFunc() {\n      func.apply( self, args )\n    }\n  }\n\n  return debounced\n\n  function clearTimer() {\n    clearTimeout( timer )\n    timer = null\n  }\n}\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`接下来我们使用刚才编写的debounce函数来测试第一个案例`}</MDXTag>\n<iframe src=\"https://terry-su.github.io/BlogCDN/iframes/js/debounce/test-search/index.html?mode=js\" ></iframe>\n<MDXTag name=\"h2\" components={components}>{`总结`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`防抖是一个高阶函数，能够将多个事件函数合并为一个，在“调整window尺寸”，“在搜索框中实时搜索键入文本”， “滚动滚动条”和“防止搜索按钮频繁点击触发多余请求”等案例中，十分有用。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`链接`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`Lodash 推荐：`}<MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://css-tricks.com/debouncing-throttling-explained-examples\"}}>{`https://css-tricks.com/debouncing-throttling-explained-examples`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`简单理解防抖定义：`}<MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://www.cnblogs.com/woodyblog/p/6238445.html\"}}>{`https://www.cnblogs.com/woodyblog/p/6238445.html`}</MDXTag></MDXTag>\n</MDXTag>\n           </MDXTag>\n  }\n}\nMDXContent.isMDXComponent = true\nrender( <MDXContent /> )\n  ","postTime":1537351320000,"comment":2,"isAutoTranslated":false,"availableOtherLocales":["en"],"importedCodes":"","siteTitle":"防抖-理解，实践并实现(苏溪云的博客)","siteMetaDescription":"防抖 Debounce JavaScript 前端 节流 防抖-理解，实践并实现 防抖（去抖），以及节流（分流）在日常开发中可能用的不多，但在特定场景，却十分有用。本文主要讨论防抖，镜像文章：节流 - 理解，实践与实现。分开讨论防抖和节流，主要是为了让一些还不太了解防抖节流的读者能... (苏溪云的博客)","categoryTitle":"分类","postTimeTitle":"发布时间","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","endingWords":"article.endingWords","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","remarkDisqusComment":"https://terrysu.disqus.com/embed.js","texts":{"siteTitle":"苏溪云的博客","siteMetaDescription":"苏溪云的原创前端技术博客 4年前端 分享主流前端技术 JavaScript ReactJS","categoryNewest":"最新文章","navArticles":"所有文章","navAbout":"关于作者"},"articleTexts":{"endingWordsExtra":"**欢迎[Star和订阅](https://github.com/Terry-Su/blogs-cn)，第一时间阅读我的最新原创前端技术博客。**","qrcodeImageUrl":"","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","category":"分类","postTime":"发布时间","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","commentOnGithub":"添加评论 (by Github Issues)"},"markedEndingWordsExtra":"<p><strong>欢迎<a href=\"https://github.com/Terry-Su/blogs-cn\">Star和订阅</a>，第一时间阅读我的最新原创前端技术博客。</strong></p>"}
