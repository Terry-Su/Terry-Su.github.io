{"pathnameRoot":"/cn/","authorUrl":"https://github.com/Terry-Su","locale":"zh_CN","logoTitle":"苏溪云","noteIsAutoTranslated":"本文为自动翻译。","copyright":{"left":"版权 © 2017-","center":"苏溪云","right":"保留所有权利"},"blogGithub":"https://github.com/Terry-Su/blogs-cn","id":"cn/demonstrate-sorting-algorithms-using-animated-demos","title":"动画演绎排序算法","path":"Technology/Algorithm","route":"/cn/demonstrate-sorting-algorithms-using-animated-demos","text":"\n\nconst layoutProps = {\n  \n};\nclass MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><Common />\n<MDXTag name=\"p\" components={components}><MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://terry-su.github.io/BlogCDN/images/simpson-evolution.jpg\",\"alt\":null}}></MDXTag>{`    `}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在学习了常用的排序算法之后，打算用动画Demo来生动形象的展现它们。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`这里包含6种排序算法，其中一半是简单算法，另一半是高级算法:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`冒泡排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`选择排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`插入排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`~`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`归并排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`希尔排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`快速排序`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`冒泡排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`这可能是最简单的一种，但是速度非常慢。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`假设我们按照棒球运动员的身高来排列队列。从最左边开始。`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`比较两个球员 `}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`如果左边的高一些，就换掉。否则,不做任何操作。`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`向右移动一个位置`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Bubble />\n<MDXTag name=\"h2\" components={components}>{`选择排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`也从最左边开始。`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`寻找从当前位置到右边的最矮球员`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将最矮球员与当前位置的球员交换`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`向右移动一个位置`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Selection />\n<MDXTag name=\"h2\" components={components}>{`插入排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在大多数情况下，这是基础排序方法中的最佳方法。它的速度是冒泡排序的两倍。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`而具体步骤比上面的排序稍微复杂一些。从左边的开始。`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`部分排序左球员`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`选择第一个未排序的球员作为标记球员`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将比标记球员矮的球员移到右边`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将标记的球员插入到第一个移动过位置的球员的前一个位置。`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Insert />\n<MDXTag name=\"h2\" components={components}>{`合并排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`合并排序算法的核心是两个已经排序的数组的合并和递归。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}<MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Merge_sort_algorithm_diagram.svg/800px-Merge_sort_algorithm_diagram.svg.png\",\"alt\":null}}></MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`如图所示，主要步骤如下:`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将数字分成两部分`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`合并两部分`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Merge />\n<MDXTag name=\"h2\" components={components}>{`希尔排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`“Shell排序”的名称是以发现它的Donald Shell命名的。它基于`}<MDXTag name=\"strong\" components={components} parentName=\"p\">{`插入排序`}</MDXTag>{`，但是增加了一个新特性，从而极大地提高了插入排序的性能。  `}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`主要步骤`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将数组按区间(例如3)划分为若干组，并对它们进行一直排序，直到所有元素都被划分和排序为止。`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`缩小区间，继续进行分割和排序，直到区间变为1。`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Shell />\n<MDXTag name=\"h2\" components={components}>{`快速排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在大多数情况下，这是最快的排序。`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`选择一个参考元素(最右边的元素)`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将数组划分为左子数组(比参考元素小的所有元素)和右子数组(比参考元素大的所有元素)`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`对左子数组和右子数组重复步骤2`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Quick />\n           </MDXTag>\n  }\n}\nMDXContent.isMDXComponent = true\nrender( <MDXContent /> )\n  ","postTime":1553738400000,"comment":5,"availableOtherLocales":["en"],"componentTextMap":{"Test":"render(<span></span>)","Common":"sharing.StyledRoot = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`\n\nsharing.StyledPlayButton = styled.button`\n  visibility: ${ props => props.isRunning ? 'hidden' : 'visible' };\n`\n\n\nrender(<span></span>)\n","Bubble":"const { StyledRoot, StyledPlayButton } = sharing\n\nclass App extends React.Component {\n  constructor(props) {\n    super( props )\n    \n    this.time = 0\n\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\n\n    this.state = {\n      data: [...this.data],\n      currentI: null,\n      currentJ: null,\n      isRunning: false\n    }\n  }\n\n  asyncUpdate(arr, i, j) {\n    const tmp = [...arr]\n    this.time = this.time + 500\n    const currentTime = this.time\n    setTimeout(() => {\n      this.setState({\n        data: [...tmp],\n        currentI: i,\n        currentJ: j\n      })\n      if (currentTime === this.time) {\n        this.setState({ isRunning: false })\n      }\n    }, this.time)\n  }\n\n  bubbleSort(arr) {\n    const { length } = arr\n    for (let i = length - 1; i > 0; i--) {\n      for (let j = 0; j < i; j++) {\n        this.asyncUpdate(arr, i, j)\n        if (arr[j] > arr[j + 1]) {\n          // swap\n          const tmp = arr[j]\n          arr[j] = arr[j + 1]\n          arr[j + 1] = tmp\n          this.asyncUpdate(arr, i, j)\n        }\n      }\n    }\n    this.asyncUpdate(arr)\n  }\n\n  getItemStyleBackground(index) {\n    if (this.state.currentJ === index) {\n      return \"red\"\n    }\n    if (this.state.currentJ != null && this.state.currentJ + 1 === index) {\n      return \"orange\"\n    }\n    if (this.state.currentI === index) {\n      return \"purple\"\n    }\n    if (this.state.currentI != null && index > this.state.currentI) {\n      return \"deepSkyBlue\"\n    }\n    return \"blue\"\n  }\n\n  play() {\n    this.time = 0\n    this.setState({ data: [...this.data], isRunning: true }, () =>\n      this.bubbleSort(this.state.data)\n    )\n  }\n\n  render() {\n    const { data, activeI, activeJ, isRunning } = this.state\n\n    return (\n      <StyledRoot>\n        <div\n          style={{\n            display: \"flex\",\n            alignItems: \"flex-end\"\n          }}\n        >\n          {data.map((num, index) => (\n            <span\n              key={index}\n              style={{\n                display: \"inline-flex\",\n                justifyContent: \"center\",\n                alignItems: \"flex-end\",\n                width: \"50px\",\n                height: `${num * 20}px`,\n                margin: \"2px\",\n                color: \"#ddd\",\n                background: this.getItemStyleBackground(index)\n              }}\n            >\n              {num}\n            </span>\n          ))}\n        </div>\n        <br />\n        <StyledPlayButton\n          isRunning={isRunning}\n          onClick={() => this.play()}\n          onMouseOver={() => this.play()}\n        >\n          play\n        </StyledPlayButton>\n      </StyledRoot>\n    )\n  }\n}\n\nrender(<App />)\n","Selection":"const { StyledRoot, StyledPlayButton } = sharing\n\nclass App extends React.Component {\n  constructor(props) {\n    super( props )\n    this.time = 0\n\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\n\n    this.state = {\n      data: [...this.data],\n      currentI: null,\n      currentJ: null,\n      isRunning: false\n    }\n  }\n\n  asyncUpdate(arr, i, j) {\n    const tmp = [...arr]\n    this.time = this.time + 500\n    const currentTime = this.time\n    setTimeout(() => {\n      this.setState({\n        data: [...tmp],\n        currentI: i,\n        currentJ: j\n      })\n      if (currentTime === this.time) {\n        this.setState({ isRunning: false })\n      }\n    }, this.time)\n  }\n\n  selectionSort(arr) {\n    const { length } = arr\n    for (let i = 0; i < length - 1; i++) {\n      let minIndex = i\n      for (let j = i; j < length - 1; j++) {\n        if (arr[j + 1] < arr[minIndex]) {\n          minIndex = j + 1\n        }\n      }\n      // swap\n      const tmp = arr[i]\n      arr[i] = arr[minIndex]\n      arr[minIndex] = tmp\n      this.asyncUpdate(arr, i)\n    }\n    this.asyncUpdate(arr, length)\n  }\n\n  getItemStyleBackground(index){\n    if (this.state.currentI != null && index > this.state.currentI) {\n      return \"deepSkyBlue\"\n    }\n    if (this.state.currentI === index) {\n      return \"grey\"\n    }\n    return \"blue\"\n  }\n\n  play() {\n    this.time = 0\n    this.setState({ data: [...this.data], isRunning: true }, () =>\n      this.selectionSort(this.state.data)\n    )\n  }\n\n  render() {\n    const { data, activeI, activeJ, isRunning } = this.state\n    return (\n      <StyledRoot>\n        <div\n          style={{\n            display: \"flex\",\n            alignItems: \"flex-end\"\n          }}\n        >\n          {data.map((num, index) => (\n            <span\n              key={index}\n              style={{\n                display: \"inline-flex\",\n                justifyContent: \"center\",\n                alignItems: \"flex-end\",\n                width: \"50px\",\n                height: `${num * 20}px`,\n                margin: \"2px\",\n                color: \"#ddd\",\n                background: this.getItemStyleBackground(index)\n              }}\n            >\n              {num}\n            </span>\n          ))}\n        </div>\n        <br />\n        <StyledPlayButton\n          isRunning={isRunning}\n          onClick={() => this.play()}\n          onMouseOver={() => this.play()}\n        >\n          play\n        </StyledPlayButton>\n      </StyledRoot>\n    )\n  }\n}\n\n\nrender(<App />)","Insert":"const { StyledRoot, StyledPlayButton } = sharing\n\nclass App extends React.Component {\n  constructor(props) {\n    super( props )\n    this.time = 0\n\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\n\n    this.state = {\n      data: [...this.data],\n      currentI: null,\n      currentJ: null,\n      isRunning: false\n    }\n  }\n\n  asyncUpdate(arr, i, j) {\n    const tmp = [...arr]\n    this.time = this.time + 500\n    const currentTime = this.time\n    setTimeout(() => {\n      this.setState({\n        data: [...tmp],\n        currentI: i,\n        currentJ: j\n      })\n      if (currentTime === this.time) {\n        this.setState({ isRunning: false })\n      }\n    }, this.time)\n  }\n\n  insertionSort(arr) {\n    let i\n    let j // j is marked item's index\n    for (j = 1; j < arr.length; j++) {\n      const tmp = arr[j] // removed marked item\n      i = j\n      this.asyncUpdate(arr, i, j)\n      while (i > 0 && arr[i - 1] >= tmp) {\n        arr[i] = arr[i - 1] // shift item right\n        i = i - 1\n      }\n      // insert\n      arr[i] = tmp\n      this.asyncUpdate(arr, i, j)\n    }\n    this.asyncUpdate(arr)\n  }\n\n  getItemStyleBackground(index) {\n    if (this.state.currentJ === index) {\n      return \"red\"\n    }\n    if (this.state.currentI === index) {\n      return \"grey\"\n    }\n    return \"blue\"\n  }\n\n  play(index) {\n    this.time = 0\n    this.setState({ data: [...this.data], isRunning: true }, () =>\n      this.insertionSort(this.state.data)\n    )\n  }\n\n  render() {\n    const { data, activeI, activeJ, isRunning } = this.state\n    return (\n      <StyledRoot>\n        <div\n          style={{\n            display: \"flex\",\n            alignItems: \"flex-end\"\n          }}\n        >\n          {data.map((num, index) => (\n            <span\n              key={index}\n              style={{\n                display: \"inline-flex\",\n                justifyContent: \"center\",\n                alignItems: \"flex-end\",\n                width: \"50px\",\n                height: `${num * 20}px`,\n                margin: \"2px\",\n                color: \"#ddd\",\n                background: this.getItemStyleBackground(index)\n              }}\n            >\n              {num}\n            </span>\n          ))}\n        </div>\n        <br />\n        <StyledPlayButton\n          isRunning={isRunning}\n          onClick={() => this.play()}\n          onMouseOver={() => this.play()}\n        >\n          play\n        </StyledPlayButton>\n      </StyledRoot>\n    )\n  }\n}\n\nrender(<App />)","Merge":"const { StyledRoot, StyledPlayButton } = sharing\n\nclass App extends React.Component {\n  constructor(props) {\n    super( props )\n    this.time = 0\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\n\n    this.state = {\n      data: [...this.data],\n      currentLeft: null,\n      currentRight: null,\n      currentMiddle: null,\n      isRunning: false\n    }\n  }\n\n  asyncUpdate(arr, left, right, middle) {\n    const tmp = [...arr]\n    this.time = this.time + 500\n    const currentTime = this.time\n    setTimeout(() => {\n      this.setState({\n        data: [...tmp],\n        currentLeft: left,\n        currentRight: right,\n        currentMiddle: middle\n      })\n      if (currentTime === this.time) {\n        this.setState({ isRunning: false })\n      }\n    }, this.time)\n  }\n\n  mergeSort(arr) {\n    const left = 0\n    const right = arr.length - 1\n    this.recurMergeSort(arr, left, right)\n    this.asyncUpdate(arr)\n  }\n\n  recurMergeSort(a, left, right) {\n    if (left == right) {\n      return\n    } else {\n      // Example: 2 / 2 = 1; 3 / 2 = 1;\n      const middle = Math.floor((left + right) / 2)\n      this.recurMergeSort(a, left, middle)\n      this.recurMergeSort(a, middle + 1, right)\n      this.merge(a, left, middle, right)\n      this.asyncUpdate(a, left, right, middle)\n    }\n  }\n\n  merge(aA, left, middle, right) {\n    let tmpSize = right - left + 1\n    // a temporary array used to re-assign value to aA\n    const tmp = []\n    let i = 0\n    let indexA = left\n    let indexB = middle + 1\n    while (indexA <= middle && indexB <= right) {\n      if (aA[indexA] < aA[indexB]) {\n        tmp[i] = aA[indexA]\n        indexA = indexA + 1\n      } else {\n        tmp[i] = aA[indexB]\n        indexB = indexB + 1\n      }\n      i = i + 1\n    }\n    while (indexA <= middle) {\n      tmp[i] = aA[indexA]\n      indexA = indexA + 1\n      i = i + 1\n    }\n    while (indexB <= right) {\n      tmp[i] = aA[indexB]\n      indexB = indexB + 1\n      i = i + 1\n    }\n    for (let j = 0; j < tmp.length; j++) {\n      aA[left + j] = tmp[j]\n    }\n  }\n\n  play() {\n    this.time = 0\n    this.setState({ data: [...this.data], isRunning: true }, () =>\n      this.mergeSort(this.state.data)\n    )\n  }\n\n  getItemStyleBackground(index) {\n    if (this.state.currentLeft === index) {\n      return \"deepSkyBlue\"\n    }\n    if (this.state.currentRight === index) {\n      return \"deepSkyBlue\"\n    }\n    if (this.state.currentLeft < index && this.state.currentRight > index) {\n      return \"deepSkyBlue\"\n    }\n    return \"blue\"\n  }\n\n  render() {\n    const { data, activeI, activeJ, isRunning } = this.state\n    return (\n      <StyledRoot>\n        <div\n          style={{\n            display: \"flex\",\n            alignItems: \"flex-end\"\n          }}\n        >\n          {data.map((num, index) => (\n            <span\n              key={index}\n              style={{\n                display: \"inline-flex\",\n                justifyContent: \"center\",\n                alignItems: \"flex-end\",\n                width: \"50px\",\n                height: `${num * 20}px`,\n                margin: \"2px\",\n                color: \"#ddd\",\n                background: this.getItemStyleBackground(index)\n              }}\n            >\n              {num}\n            </span>\n          ))}\n        </div>\n        <br />\n        <StyledPlayButton\n          isRunning={isRunning}\n          onClick={() => this.play()}\n          onMouseOver={() => this.play()}\n        >\n          play\n        </StyledPlayButton>\n      </StyledRoot>\n    )\n  }\n}\n\n\nrender(<App />)","Shell":"const { StyledRoot, StyledPlayButton } = sharing\n\nclass App extends React.Component {\n  constructor(props) {\n    super( props )\n    this.time = 0\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\n\n    this.state = {\n      data: [...this.data],\n      currentI: null,\n      currentJ: null\n    }\n  }\n\n  asyncUpdate(arr, i, j) {\n    const tmp = [...arr]\n    this.time = this.time + 500\n    const currentTime = this.time\n    setTimeout(() => {\n      this.setState({\n        data: [...tmp],\n        currentI: i,\n        currentJ: j\n      })\n      if (currentTime === this.time) {\n        this.setState({ isRunning: false })\n      }\n    }, this.time)\n  }\n\n  shellSort(arr) {\n    this.insertionSortByH(arr, 3)\n    this.insertionSortByH(arr, 1)\n    this.asyncUpdate(arr)\n  }\n\n  insertionSortByH(a, h) {\n    const length = a.length\n    for (let i = 0; i < h; i++) {\n      let size = Math.floor((length - i) / h)\n      if (size > 0) {\n        // insertion sort\n        let input\n        let out // out is marked item\n\n        for (out = i; out < length; out += h) {\n          const tmp = a[out] // removed marked item\n          input = out\n\n          this.asyncUpdate(a, input, out)\n          while (input > 0 && input - h >= 0 && a[input - h] >= tmp) {\n            a[input] = a[input - h] // shift item right\n            input = input - h\n          }\n\n          // insert\n          a[input] = tmp\n          this.asyncUpdate(a, input, out)\n        }\n      }\n    }\n  }\n\n  getItemStyleBackground(index) {\n    if (this.state.currentJ === index) {\n      return \"red\"\n    }\n    if (this.state.currentI === index) {\n      return \"grey\"\n    }\n\n    return \"blue\"\n  }\n\n  play() {\n    this.time = 0\n    this.setState({ data: [...this.data], isRunning: true }, () =>\n      this.shellSort(this.state.data)\n    )\n  }\n\n  render() {\n    const { data, activeI, activeJ, isRunning } = this.state\n    return (\n      <StyledRoot>\n        <div\n          style={{\n            display: \"flex\",\n            alignItems: \"flex-end\"\n          }}\n        >\n          {data.map((num, index) => (\n            <span\n              key={index}\n              style={{\n                display: \"inline-flex\",\n                justifyContent: \"center\",\n                alignItems: \"flex-end\",\n                width: \"50px\",\n                height: `${num * 20}px`,\n                margin: \"2px\",\n                color: \"#ddd\",\n                background: this.getItemStyleBackground(index)\n              }}\n            >\n              {num}\n            </span>\n          ))}\n        </div>\n        <br />\n        <StyledPlayButton\n          isRunning={isRunning}\n          onClick={() => this.play()}\n          onMouseOver={() => this.play()}\n        >\n          play\n        </StyledPlayButton>\n      </StyledRoot>\n    )\n  }\n}\n\n\nrender(<App />)","Quick":"const { StyledRoot, StyledPlayButton } = sharing\n\nclass App extends React.Component {\n  constructor(props) {\n    super( props )\n    this.time = 0\n\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\n\n    this.state = {\n      data: [...this.data],\n      currentLeftIndex: null,\n      currentRightIndex: null,\n      currentPivotIndex: null,\n      currentTmpLeftIndex: null,\n      currentTmpRightIndex: null,\n      isRunning: false\n    }\n  }\n\n  asyncUpdate(\n    arr,\n    leftIndex,\n    rightIndex,\n    pivotIndex,\n    tmpLeftIndex,\n    tmpRightIndex\n  ) {\n    const tmp = [...arr]\n    this.time = this.time + 500\n    const currentTime = this.time\n    setTimeout(() => {\n      this.setState({\n        data: [...tmp],\n        currentLeftIndex: leftIndex,\n        currentRightIndex: rightIndex,\n        currentPivotIndex: pivotIndex,\n        currentTmpLeftIndex: tmpLeftIndex,\n        currentTmpRightIndex: tmpRightIndex\n      })\n      if (currentTime === this.time) {\n        this.setState({ isRunning: false })\n      }\n    }, this.time)\n  }\n\n  quickSort(arr) {\n    this.recurQuickSort(arr, 0, arr.length - 1)\n    this.asyncUpdate(arr)\n  }\n\n  recurQuickSort(a, leftIndex, rightIndex) {\n    if (leftIndex >= rightIndex) {\n      return\n    }\n\n    this.asyncUpdate(a, leftIndex, rightIndex, rightIndex)\n    const pivotIndex = this.partition(a, leftIndex, rightIndex, rightIndex)\n    this.asyncUpdate(a, leftIndex, rightIndex, pivotIndex)\n    this.asyncUpdate(a, leftIndex, rightIndex, pivotIndex)\n    this.recurQuickSort(a, leftIndex, pivotIndex - 1)\n    this.recurQuickSort(a, pivotIndex + 1, rightIndex)\n  }\n\n  partition(a, leftIndex, rightIndex, pivotIndex) {\n    let tmpLeftIndex = leftIndex - 1\n    let tmpRightIndex = rightIndex - 1 + 1\n    const pivot = a[pivotIndex]\n\n    while (true) {\n      do {\n        tmpLeftIndex = tmpLeftIndex + 1\n      } while (tmpLeftIndex < rightIndex && a[tmpLeftIndex] <= pivot)\n\n      do {\n        tmpRightIndex = tmpRightIndex - 1\n      } while (tmpRightIndex > 0 && a[tmpRightIndex] >= pivot)\n\n      if (tmpLeftIndex >= tmpRightIndex) {\n        break\n      } else {\n        this.asyncUpdate(\n          a,\n          leftIndex,\n          rightIndex,\n          pivotIndex,\n          tmpLeftIndex,\n          tmpRightIndex\n        )\n        this.swap(a, tmpLeftIndex, tmpRightIndex)\n        this.asyncUpdate(\n          a,\n          leftIndex,\n          rightIndex,\n          pivotIndex,\n          tmpLeftIndex,\n          tmpRightIndex\n        )\n      }\n    }\n    this.swap(a, tmpLeftIndex, pivotIndex)\n    return tmpLeftIndex\n  }\n\n  swap(arr, aIndex, bIndex) {\n    const tmp = arr[aIndex]\n    arr[aIndex] = arr[bIndex]\n    arr[bIndex] = tmp\n  }\n\n  getItemStyleBackground (index) {\n    if (this.state.currentPivotIndex === index) {\n      return \"grey\"\n    }\n    if (this.state.currentTmpLeftIndex === index) {\n      return \"red\"\n    }\n    if (this.state.currentTmpRightIndex === index) {\n      return \"red\"\n    }\n    if (\n      (this.state.currentLeftIndex < index &&\n        this.state.currentRightIndex > index) ||\n      this.state.currentLeftIndex === index ||\n      this.state.currentRightIndex === index\n    ) {\n      return \"deepSkyBlue\"\n    }\n    return \"blue\"\n  }\n\n  play() {\n    this.time = 0\n    this.setState({ data: [...this.data], isRunning: true }, () =>\n      this.quickSort(this.state.data)\n    )\n  }\n\n  render() {\n    const { data, activeI, activeJ, isRunning } = this.state\n    return (\n      <StyledRoot>\n        <div\n          style={{\n            display: \"flex\",\n            alignItems: \"flex-end\"\n          }}\n        >\n          {data.map((num, index) => (\n            <span\n              key={index}\n              style={{\n                display: \"inline-flex\",\n                justifyContent: \"center\",\n                alignItems: \"flex-end\",\n                width: \"50px\",\n                height: `${num * 20}px`,\n                margin: \"2px\",\n                color: \"#ddd\",\n                background: this.getItemStyleBackground(index)\n              }}\n            >\n              {num}\n            </span>\n          ))}\n        </div>\n        <br />\n        <StyledPlayButton\n          isRunning={isRunning}\n          onClick={() => this.play()}\n          onMouseOver={() => this.play()}\n        >\n          play\n        </StyledPlayButton>\n      </StyledRoot>\n    )\n  }\n}\n\n\nrender(<App />)"},"siteTitle":"动画演绎排序算法(苏溪云的博客)","siteMetaDescription":" 动画演绎排序算法 \n\n \n\n在学习了常用的排序算法之后，打算用动画Demo来生动形象的展现它们。\n\n这里包含6种排序算法，其中一半是简单算法，另一半是高级算法:\n\n 冒泡排序\n 选择排序\n 插入排序\n ~\n 归并排序\n... (苏溪云的博客)","categoryTitle":"分类","postTimeTitle":"发布时间","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","endingWords":"article.endingWords","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","remarkDisqusComment":"https://terrysu.disqus.com/embed.js","texts":{"siteTitle":"苏溪云的博客","siteMetaDescription":"苏溪云的原创前端技术博客 4年前端 分享主流前端技术 JavaScript ReactJS","categoryNewest":"最新文章","navArticles":"所有文章","navAbout":"关于作者"},"articleTexts":{"endingWordsExtra":"**欢迎[Star和订阅](https://github.com/Terry-Su/blogs-cn)，第一时间阅读我的最新原创前端技术博客。**","qrcodeImageUrl":"","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","category":"分类","postTime":"发布时间","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","commentOnGithub":"添加评论 (by Github Issues)"},"markedEndingWordsExtra":"<p><strong>欢迎<a href=\"https://github.com/Terry-Su/blogs-cn\">Star和订阅</a>，第一时间阅读我的最新原创前端技术博客。</strong></p>"}
