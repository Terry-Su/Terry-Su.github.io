{"pathnameRoot":"/cn/","authorUrl":"https://github.com/Terry-Su","locale":"zh_CN","logoTitle":"苏溪云","noteIsAutoTranslated":"本文为自动翻译。","copyright":{"left":"版权 © 2017-","center":"苏溪云","right":"保留所有权利"},"blogGithub":"https://github.com/Terry-Su/blogs-cn","id":"cn/demonstrate-sorting-algorithms-using-animated-demos","title":"动画演绎排序算法","path":"Technology/Algorithm","route":"/cn/demonstrate-sorting-algorithms-using-animated-demos","text":"\n\nconst layoutProps = {\n  \n};\nclass MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><MDXTag name=\"p\" components={components}><MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://terry-su.github.io/BlogCDN/images/simpson-evolution.jpg\",\"alt\":null}}></MDXTag>{`    `}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在学习了常用的排序算法之后，打算用动画Demo来生动形象的展现它们。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`这里包含6种排序算法，其中一半是简单算法，另一半是高级算法:`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`冒泡排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`选择排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`插入排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`~`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`归并排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`希尔排序`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`快速排序`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`冒泡排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`这可能是最简单的一种，但是速度非常慢。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`假设我们按照棒球运动员的身高来排列队列。从最左边开始。`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`比较两个球员 `}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`如果左边的高一些，就换掉。否则,不做任何操作。`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`向右移动一个位置`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Bubble />\n<MDXTag name=\"h2\" components={components}>{`选择排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`也从最左边开始。`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`寻找从当前位置到右边的最矮球员`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将最矮球员与当前位置的球员交换`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`向右移动一个位置`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Selection />\n<MDXTag name=\"h2\" components={components}>{`插入排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在大多数情况下，这是基础排序方法中的最佳方法。它的速度是冒泡排序的两倍。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}{`而具体步骤比上面的排序稍微复杂一些。从左边的开始。`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`部分排序左球员`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`选择第一个未排序的球员作为标记球员`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将比标记球员矮的球员移到右边`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将标记的球员插入到第一个移动过位置的球员的前一个位置。`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Insert />\n<MDXTag name=\"h2\" components={components}>{`合并排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`合并排序算法的核心是两个已经排序的数组的合并和递归。`}<MDXTag name=\"br\" components={components} parentName=\"p\"></MDXTag>{`\n`}<MDXTag name=\"img\" components={components} parentName=\"p\" props={{\"src\":\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Merge_sort_algorithm_diagram.svg/800px-Merge_sort_algorithm_diagram.svg.png\",\"alt\":null}}></MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`如图所示，主要步骤如下:`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将数字分成两部分`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`合并两部分`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Merge />\n<MDXTag name=\"h2\" components={components}>{`希尔排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`“Shell排序”的名称是以发现它的Donald Shell命名的。它基于`}<MDXTag name=\"strong\" components={components} parentName=\"p\">{`插入排序`}</MDXTag>{`，但是增加了一个新特性，从而极大地提高了插入排序的性能。  `}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`主要步骤`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将数组按区间(例如3)划分为若干组，并对它们进行一直排序，直到所有元素都被划分和排序为止。`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`缩小区间，继续进行分割和排序，直到区间变为1。`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<Shell />\n<MDXTag name=\"h2\" components={components}>{`快速排序`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在大多数情况下，这是最快的排序。`}</MDXTag>\n<MDXTag name=\"ol\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`选择一个参考元素(最右边的元素)`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`将数组划分为左子数组(比参考元素小的所有元素)和右子数组(比参考元素大的所有元素)`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ol\">\n<MDXTag name=\"p\" components={components} parentName=\"li\">{`对左子数组和右子数组重复步骤2`}</MDXTag>\n</MDXTag>\n</MDXTag>\n           </MDXTag>\n  }\n}\nMDXContent.isMDXComponent = true\nrender( <MDXContent /> )\n  ","postTime":1553738400000,"comment":5,"availableOtherLocales":["en"],"importedCodes":"\nconst StyledRoot = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n`\r\n\r\nconst StyledPlayButton = styled.button`\r\n  visibility: ${ props => props.isRunning ? 'hidden' : 'visible' };\r\n`\r\n\r\n\r\n\nclass Bubble extends React.Component {\r\n  constructor(props) {\r\n    super( props )\r\n    \r\n    this.time = 0\r\n\r\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\r\n\r\n    this.state = {\r\n      data: [...this.data],\r\n      currentI: null,\r\n      currentJ: null,\r\n      isRunning: false\r\n    }\r\n  }\r\n\r\n  asyncUpdate(arr, i, j) {\r\n    const tmp = [...arr]\r\n    this.time = this.time + 500\r\n    const currentTime = this.time\r\n    setTimeout(() => {\r\n      this.setState({\r\n        data: [...tmp],\r\n        currentI: i,\r\n        currentJ: j\r\n      })\r\n      if (currentTime === this.time) {\r\n        this.setState({ isRunning: false })\r\n      }\r\n    }, this.time)\r\n  }\r\n\r\n  bubbleSort(arr) {\r\n    const { length } = arr\r\n    for (let i = length - 1; i > 0; i--) {\r\n      for (let j = 0; j < i; j++) {\r\n        this.asyncUpdate(arr, i, j)\r\n        if (arr[j] > arr[j + 1]) {\r\n          // swap\r\n          const tmp = arr[j]\r\n          arr[j] = arr[j + 1]\r\n          arr[j + 1] = tmp\r\n          this.asyncUpdate(arr, i, j)\r\n        }\r\n      }\r\n    }\r\n    this.asyncUpdate(arr)\r\n  }\r\n\r\n  getItemStyleBackground(index) {\r\n    if (this.state.currentJ === index) {\r\n      return \"red\"\r\n    }\r\n    if (this.state.currentJ != null && this.state.currentJ + 1 === index) {\r\n      return \"orange\"\r\n    }\r\n    if (this.state.currentI === index) {\r\n      return \"purple\"\r\n    }\r\n    if (this.state.currentI != null && index > this.state.currentI) {\r\n      return \"deepSkyBlue\"\r\n    }\r\n    return \"blue\"\r\n  }\r\n\r\n  play() {\r\n    this.time = 0\r\n    this.setState({ data: [...this.data], isRunning: true }, () =>\r\n      this.bubbleSort(this.state.data)\r\n    )\r\n  }\r\n\r\n  render() {\r\n    const { data, activeI, activeJ, isRunning } = this.state\r\n\r\n    return (\r\n      <StyledRoot>\r\n        <div\r\n          style={{\r\n            display: \"flex\",\r\n            alignItems: \"flex-end\"\r\n          }}\r\n        >\r\n          {data.map((num, index) => (\r\n            <span\r\n              key={index}\r\n              style={{\r\n                display: \"inline-flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"flex-end\",\r\n                width: \"50px\",\r\n                height: `${num * 20}px`,\r\n                margin: \"2px\",\r\n                color: \"#ddd\",\r\n                background: this.getItemStyleBackground(index)\r\n              }}\r\n            >\r\n              {num}\r\n            </span>\r\n          ))}\r\n        </div>\r\n        <br />\r\n        <StyledPlayButton\r\n          isRunning={isRunning}\r\n          onClick={() => this.play()}\r\n          onMouseOver={() => this.play()}\r\n        >\r\n          play\r\n        </StyledPlayButton>\r\n      </StyledRoot>\r\n    )\r\n  }\r\n}\r\n\nclass Selection extends React.Component {\r\n  constructor(props) {\r\n    super( props )\r\n    this.time = 0\r\n\r\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\r\n\r\n    this.state = {\r\n      data: [...this.data],\r\n      currentI: null,\r\n      currentJ: null,\r\n      isRunning: false\r\n    }\r\n  }\r\n\r\n  asyncUpdate(arr, i, j) {\r\n    const tmp = [...arr]\r\n    this.time = this.time + 500\r\n    const currentTime = this.time\r\n    setTimeout(() => {\r\n      this.setState({\r\n        data: [...tmp],\r\n        currentI: i,\r\n        currentJ: j\r\n      })\r\n      if (currentTime === this.time) {\r\n        this.setState({ isRunning: false })\r\n      }\r\n    }, this.time)\r\n  }\r\n\r\n  selectionSort(arr) {\r\n    const { length } = arr\r\n    for (let i = 0; i < length - 1; i++) {\r\n      let minIndex = i\r\n      for (let j = i; j < length - 1; j++) {\r\n        if (arr[j + 1] < arr[minIndex]) {\r\n          minIndex = j + 1\r\n        }\r\n      }\r\n      // swap\r\n      const tmp = arr[i]\r\n      arr[i] = arr[minIndex]\r\n      arr[minIndex] = tmp\r\n      this.asyncUpdate(arr, i)\r\n    }\r\n    this.asyncUpdate(arr, length)\r\n  }\r\n\r\n  getItemStyleBackground(index){\r\n    if (this.state.currentI != null && index > this.state.currentI) {\r\n      return \"deepSkyBlue\"\r\n    }\r\n    if (this.state.currentI === index) {\r\n      return \"grey\"\r\n    }\r\n    return \"blue\"\r\n  }\r\n\r\n  play() {\r\n    this.time = 0\r\n    this.setState({ data: [...this.data], isRunning: true }, () =>\r\n      this.selectionSort(this.state.data)\r\n    )\r\n  }\r\n\r\n  render() {\r\n    const { data, activeI, activeJ, isRunning } = this.state\r\n    return (\r\n      <StyledRoot>\r\n        <div\r\n          style={{\r\n            display: \"flex\",\r\n            alignItems: \"flex-end\"\r\n          }}\r\n        >\r\n          {data.map((num, index) => (\r\n            <span\r\n              key={index}\r\n              style={{\r\n                display: \"inline-flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"flex-end\",\r\n                width: \"50px\",\r\n                height: `${num * 20}px`,\r\n                margin: \"2px\",\r\n                color: \"#ddd\",\r\n                background: this.getItemStyleBackground(index)\r\n              }}\r\n            >\r\n              {num}\r\n            </span>\r\n          ))}\r\n        </div>\r\n        <br />\r\n        <StyledPlayButton\r\n          isRunning={isRunning}\r\n          onClick={() => this.play()}\r\n          onMouseOver={() => this.play()}\r\n        >\r\n          play\r\n        </StyledPlayButton>\r\n      </StyledRoot>\r\n    )\r\n  }\r\n}\r\n\r\n\nclass Insert extends React.Component {\r\n  constructor(props) {\r\n    super( props )\r\n    this.time = 0\r\n\r\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\r\n\r\n    this.state = {\r\n      data: [...this.data],\r\n      currentI: null,\r\n      currentJ: null,\r\n      isRunning: false\r\n    }\r\n  }\r\n\r\n  asyncUpdate(arr, i, j) {\r\n    const tmp = [...arr]\r\n    this.time = this.time + 500\r\n    const currentTime = this.time\r\n    setTimeout(() => {\r\n      this.setState({\r\n        data: [...tmp],\r\n        currentI: i,\r\n        currentJ: j\r\n      })\r\n      if (currentTime === this.time) {\r\n        this.setState({ isRunning: false })\r\n      }\r\n    }, this.time)\r\n  }\r\n\r\n  insertionSort(arr) {\r\n    let i\r\n    let j // j is marked item's index\r\n    for (j = 1; j < arr.length; j++) {\r\n      const tmp = arr[j] // removed marked item\r\n      i = j\r\n      this.asyncUpdate(arr, i, j)\r\n      while (i > 0 && arr[i - 1] >= tmp) {\r\n        arr[i] = arr[i - 1] // shift item right\r\n        i = i - 1\r\n      }\r\n      // insert\r\n      arr[i] = tmp\r\n      this.asyncUpdate(arr, i, j)\r\n    }\r\n    this.asyncUpdate(arr)\r\n  }\r\n\r\n  getItemStyleBackground(index) {\r\n    if (this.state.currentJ === index) {\r\n      return \"red\"\r\n    }\r\n    if (this.state.currentI === index) {\r\n      return \"grey\"\r\n    }\r\n    return \"blue\"\r\n  }\r\n\r\n  play(index) {\r\n    this.time = 0\r\n    this.setState({ data: [...this.data], isRunning: true }, () =>\r\n      this.insertionSort(this.state.data)\r\n    )\r\n  }\r\n\r\n  render() {\r\n    const { data, activeI, activeJ, isRunning } = this.state\r\n    return (\r\n      <StyledRoot>\r\n        <div\r\n          style={{\r\n            display: \"flex\",\r\n            alignItems: \"flex-end\"\r\n          }}\r\n        >\r\n          {data.map((num, index) => (\r\n            <span\r\n              key={index}\r\n              style={{\r\n                display: \"inline-flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"flex-end\",\r\n                width: \"50px\",\r\n                height: `${num * 20}px`,\r\n                margin: \"2px\",\r\n                color: \"#ddd\",\r\n                background: this.getItemStyleBackground(index)\r\n              }}\r\n            >\r\n              {num}\r\n            </span>\r\n          ))}\r\n        </div>\r\n        <br />\r\n        <StyledPlayButton\r\n          isRunning={isRunning}\r\n          onClick={() => this.play()}\r\n          onMouseOver={() => this.play()}\r\n        >\r\n          play\r\n        </StyledPlayButton>\r\n      </StyledRoot>\r\n    )\r\n  }\r\n}\nclass Merge extends React.Component {\r\n  constructor(props) {\r\n    super( props )\r\n    this.time = 0\r\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\r\n\r\n    this.state = {\r\n      data: [...this.data],\r\n      currentLeft: null,\r\n      currentRight: null,\r\n      currentMiddle: null,\r\n      isRunning: false\r\n    }\r\n  }\r\n\r\n  asyncUpdate(arr, left, right, middle) {\r\n    const tmp = [...arr]\r\n    this.time = this.time + 500\r\n    const currentTime = this.time\r\n    setTimeout(() => {\r\n      this.setState({\r\n        data: [...tmp],\r\n        currentLeft: left,\r\n        currentRight: right,\r\n        currentMiddle: middle\r\n      })\r\n      if (currentTime === this.time) {\r\n        this.setState({ isRunning: false })\r\n      }\r\n    }, this.time)\r\n  }\r\n\r\n  mergeSort(arr) {\r\n    const left = 0\r\n    const right = arr.length - 1\r\n    this.recurMergeSort(arr, left, right)\r\n    this.asyncUpdate(arr)\r\n  }\r\n\r\n  recurMergeSort(a, left, right) {\r\n    if (left == right) {\r\n      return\r\n    } else {\r\n      // Example: 2 / 2 = 1; 3 / 2 = 1;\r\n      const middle = Math.floor((left + right) / 2)\r\n      this.recurMergeSort(a, left, middle)\r\n      this.recurMergeSort(a, middle + 1, right)\r\n      this.merge(a, left, middle, right)\r\n      this.asyncUpdate(a, left, right, middle)\r\n    }\r\n  }\r\n\r\n  merge(aA, left, middle, right) {\r\n    let tmpSize = right - left + 1\r\n    // a temporary array used to re-assign value to aA\r\n    const tmp = []\r\n    let i = 0\r\n    let indexA = left\r\n    let indexB = middle + 1\r\n    while (indexA <= middle && indexB <= right) {\r\n      if (aA[indexA] < aA[indexB]) {\r\n        tmp[i] = aA[indexA]\r\n        indexA = indexA + 1\r\n      } else {\r\n        tmp[i] = aA[indexB]\r\n        indexB = indexB + 1\r\n      }\r\n      i = i + 1\r\n    }\r\n    while (indexA <= middle) {\r\n      tmp[i] = aA[indexA]\r\n      indexA = indexA + 1\r\n      i = i + 1\r\n    }\r\n    while (indexB <= right) {\r\n      tmp[i] = aA[indexB]\r\n      indexB = indexB + 1\r\n      i = i + 1\r\n    }\r\n    for (let j = 0; j < tmp.length; j++) {\r\n      aA[left + j] = tmp[j]\r\n    }\r\n  }\r\n\r\n  play() {\r\n    this.time = 0\r\n    this.setState({ data: [...this.data], isRunning: true }, () =>\r\n      this.mergeSort(this.state.data)\r\n    )\r\n  }\r\n\r\n  getItemStyleBackground(index) {\r\n    if (this.state.currentLeft === index) {\r\n      return \"deepSkyBlue\"\r\n    }\r\n    if (this.state.currentRight === index) {\r\n      return \"deepSkyBlue\"\r\n    }\r\n    if (this.state.currentLeft < index && this.state.currentRight > index) {\r\n      return \"deepSkyBlue\"\r\n    }\r\n    return \"blue\"\r\n  }\r\n\r\n  render() {\r\n    const { data, activeI, activeJ, isRunning } = this.state\r\n    return (\r\n      <StyledRoot>\r\n        <div\r\n          style={{\r\n            display: \"flex\",\r\n            alignItems: \"flex-end\"\r\n          }}\r\n        >\r\n          {data.map((num, index) => (\r\n            <span\r\n              key={index}\r\n              style={{\r\n                display: \"inline-flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"flex-end\",\r\n                width: \"50px\",\r\n                height: `${num * 20}px`,\r\n                margin: \"2px\",\r\n                color: \"#ddd\",\r\n                background: this.getItemStyleBackground(index)\r\n              }}\r\n            >\r\n              {num}\r\n            </span>\r\n          ))}\r\n        </div>\r\n        <br />\r\n        <StyledPlayButton\r\n          isRunning={isRunning}\r\n          onClick={() => this.play()}\r\n          onMouseOver={() => this.play()}\r\n        >\r\n          play\r\n        </StyledPlayButton>\r\n      </StyledRoot>\r\n    )\r\n  }\r\n}\r\n\nclass Shell extends React.Component {\r\n  constructor(props) {\r\n    super( props )\r\n    this.time = 0\r\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\r\n\r\n    this.state = {\r\n      data: [...this.data],\r\n      currentI: null,\r\n      currentJ: null\r\n    }\r\n  }\r\n\r\n  asyncUpdate(arr, i, j) {\r\n    const tmp = [...arr]\r\n    this.time = this.time + 500\r\n    const currentTime = this.time\r\n    setTimeout(() => {\r\n      this.setState({\r\n        data: [...tmp],\r\n        currentI: i,\r\n        currentJ: j\r\n      })\r\n      if (currentTime === this.time) {\r\n        this.setState({ isRunning: false })\r\n      }\r\n    }, this.time)\r\n  }\r\n\r\n  shellSort(arr) {\r\n    this.insertionSortByH(arr, 3)\r\n    this.insertionSortByH(arr, 1)\r\n    this.asyncUpdate(arr)\r\n  }\r\n\r\n  insertionSortByH(a, h) {\r\n    const length = a.length\r\n    for (let i = 0; i < h; i++) {\r\n      let size = Math.floor((length - i) / h)\r\n      if (size > 0) {\r\n        // insertion sort\r\n        let input\r\n        let out // out is marked item\r\n\r\n        for (out = i; out < length; out += h) {\r\n          const tmp = a[out] // removed marked item\r\n          input = out\r\n\r\n          this.asyncUpdate(a, input, out)\r\n          while (input > 0 && input - h >= 0 && a[input - h] >= tmp) {\r\n            a[input] = a[input - h] // shift item right\r\n            input = input - h\r\n          }\r\n\r\n          // insert\r\n          a[input] = tmp\r\n          this.asyncUpdate(a, input, out)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getItemStyleBackground(index) {\r\n    if (this.state.currentJ === index) {\r\n      return \"red\"\r\n    }\r\n    if (this.state.currentI === index) {\r\n      return \"grey\"\r\n    }\r\n\r\n    return \"blue\"\r\n  }\r\n\r\n  play() {\r\n    this.time = 0\r\n    this.setState({ data: [...this.data], isRunning: true }, () =>\r\n      this.shellSort(this.state.data)\r\n    )\r\n  }\r\n\r\n  render() {\r\n    const { data, activeI, activeJ, isRunning } = this.state\r\n    return (\r\n      <StyledRoot>\r\n        <div\r\n          style={{\r\n            display: \"flex\",\r\n            alignItems: \"flex-end\"\r\n          }}\r\n        >\r\n          {data.map((num, index) => (\r\n            <span\r\n              key={index}\r\n              style={{\r\n                display: \"inline-flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"flex-end\",\r\n                width: \"50px\",\r\n                height: `${num * 20}px`,\r\n                margin: \"2px\",\r\n                color: \"#ddd\",\r\n                background: this.getItemStyleBackground(index)\r\n              }}\r\n            >\r\n              {num}\r\n            </span>\r\n          ))}\r\n        </div>\r\n        <br />\r\n        <StyledPlayButton\r\n          isRunning={isRunning}\r\n          onClick={() => this.play()}\r\n          onMouseOver={() => this.play()}\r\n        >\r\n          play\r\n        </StyledPlayButton>\r\n      </StyledRoot>\r\n    )\r\n  }\r\n}\r\n\r\n\nclass Quick extends React.Component {\r\n  constructor(props) {\r\n    super( props )\r\n    this.time = 0\r\n\r\n    this.data = [8, 9, 4, 6, 3, 2, 1, 7, 5]\r\n\r\n    this.state = {\r\n      data: [...this.data],\r\n      currentLeftIndex: null,\r\n      currentRightIndex: null,\r\n      currentPivotIndex: null,\r\n      currentTmpLeftIndex: null,\r\n      currentTmpRightIndex: null,\r\n      isRunning: false\r\n    }\r\n  }\r\n\r\n  asyncUpdate(\r\n    arr,\r\n    leftIndex,\r\n    rightIndex,\r\n    pivotIndex,\r\n    tmpLeftIndex,\r\n    tmpRightIndex\r\n  ) {\r\n    const tmp = [...arr]\r\n    this.time = this.time + 500\r\n    const currentTime = this.time\r\n    setTimeout(() => {\r\n      this.setState({\r\n        data: [...tmp],\r\n        currentLeftIndex: leftIndex,\r\n        currentRightIndex: rightIndex,\r\n        currentPivotIndex: pivotIndex,\r\n        currentTmpLeftIndex: tmpLeftIndex,\r\n        currentTmpRightIndex: tmpRightIndex\r\n      })\r\n      if (currentTime === this.time) {\r\n        this.setState({ isRunning: false })\r\n      }\r\n    }, this.time)\r\n  }\r\n\r\n  quickSort(arr) {\r\n    this.recurQuickSort(arr, 0, arr.length - 1)\r\n    this.asyncUpdate(arr)\r\n  }\r\n\r\n  recurQuickSort(a, leftIndex, rightIndex) {\r\n    if (leftIndex >= rightIndex) {\r\n      return\r\n    }\r\n\r\n    this.asyncUpdate(a, leftIndex, rightIndex, rightIndex)\r\n    const pivotIndex = this.partition(a, leftIndex, rightIndex, rightIndex)\r\n    this.asyncUpdate(a, leftIndex, rightIndex, pivotIndex)\r\n    this.asyncUpdate(a, leftIndex, rightIndex, pivotIndex)\r\n    this.recurQuickSort(a, leftIndex, pivotIndex - 1)\r\n    this.recurQuickSort(a, pivotIndex + 1, rightIndex)\r\n  }\r\n\r\n  partition(a, leftIndex, rightIndex, pivotIndex) {\r\n    let tmpLeftIndex = leftIndex - 1\r\n    let tmpRightIndex = rightIndex - 1 + 1\r\n    const pivot = a[pivotIndex]\r\n\r\n    while (true) {\r\n      do {\r\n        tmpLeftIndex = tmpLeftIndex + 1\r\n      } while (tmpLeftIndex < rightIndex && a[tmpLeftIndex] <= pivot)\r\n\r\n      do {\r\n        tmpRightIndex = tmpRightIndex - 1\r\n      } while (tmpRightIndex > 0 && a[tmpRightIndex] >= pivot)\r\n\r\n      if (tmpLeftIndex >= tmpRightIndex) {\r\n        break\r\n      } else {\r\n        this.asyncUpdate(\r\n          a,\r\n          leftIndex,\r\n          rightIndex,\r\n          pivotIndex,\r\n          tmpLeftIndex,\r\n          tmpRightIndex\r\n        )\r\n        this.swap(a, tmpLeftIndex, tmpRightIndex)\r\n        this.asyncUpdate(\r\n          a,\r\n          leftIndex,\r\n          rightIndex,\r\n          pivotIndex,\r\n          tmpLeftIndex,\r\n          tmpRightIndex\r\n        )\r\n      }\r\n    }\r\n    this.swap(a, tmpLeftIndex, pivotIndex)\r\n    return tmpLeftIndex\r\n  }\r\n\r\n  swap(arr, aIndex, bIndex) {\r\n    const tmp = arr[aIndex]\r\n    arr[aIndex] = arr[bIndex]\r\n    arr[bIndex] = tmp\r\n  }\r\n\r\n  getItemStyleBackground (index) {\r\n    if (this.state.currentPivotIndex === index) {\r\n      return \"grey\"\r\n    }\r\n    if (this.state.currentTmpLeftIndex === index) {\r\n      return \"red\"\r\n    }\r\n    if (this.state.currentTmpRightIndex === index) {\r\n      return \"red\"\r\n    }\r\n    if (\r\n      (this.state.currentLeftIndex < index &&\r\n        this.state.currentRightIndex > index) ||\r\n      this.state.currentLeftIndex === index ||\r\n      this.state.currentRightIndex === index\r\n    ) {\r\n      return \"deepSkyBlue\"\r\n    }\r\n    return \"blue\"\r\n  }\r\n\r\n  play() {\r\n    this.time = 0\r\n    this.setState({ data: [...this.data], isRunning: true }, () =>\r\n      this.quickSort(this.state.data)\r\n    )\r\n  }\r\n\r\n  render() {\r\n    const { data, activeI, activeJ, isRunning } = this.state\r\n    return (\r\n      <StyledRoot>\r\n        <div\r\n          style={{\r\n            display: \"flex\",\r\n            alignItems: \"flex-end\"\r\n          }}\r\n        >\r\n          {data.map((num, index) => (\r\n            <span\r\n              key={index}\r\n              style={{\r\n                display: \"inline-flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"flex-end\",\r\n                width: \"50px\",\r\n                height: `${num * 20}px`,\r\n                margin: \"2px\",\r\n                color: \"#ddd\",\r\n                background: this.getItemStyleBackground(index)\r\n              }}\r\n            >\r\n              {num}\r\n            </span>\r\n          ))}\r\n        </div>\r\n        <br />\r\n        <StyledPlayButton\r\n          isRunning={isRunning}\r\n          onClick={() => this.play()}\r\n          onMouseOver={() => this.play()}\r\n        >\r\n          play\r\n        </StyledPlayButton>\r\n      </StyledRoot>\r\n    )\r\n  }\r\n}","siteTitle":"动画演绎排序算法(苏溪云的博客)","siteMetaDescription":" 动画演绎排序算法  \n\n在学习了常用的排序算法之后，打算用动画Demo来生动形象的展现它们。\n\n这里包含6种排序算法，其中一半是简单算法，另一半是高级算法:\n\n 冒泡排序\n 选择排序\n 插入排序\n ~\n 归并排序\n 希... (苏溪云的博客)","categoryTitle":"分类","postTimeTitle":"发布时间","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","endingWords":"article.endingWords","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","remarkDisqusComment":"https://terrysu.disqus.com/embed.js","texts":{"siteTitle":"苏溪云的博客","siteMetaDescription":"苏溪云的原创前端技术博客 4年前端 分享主流前端技术 JavaScript ReactJS","categoryNewest":"最近发布","navArticles":"所有文章","navAbout":"关于作者"},"articleTexts":{"endingWordsExtra":"**感谢你的阅读。欢迎通过微信（扫描下方二维码）或[Github](https://github.com/Terry-Su/blogs-cn)订阅我的博客。**\n\n ![微信公众号:苏溪云的博客](https://user-images.githubusercontent.com/23733477/77869172-2459f400-7270-11ea-8a84-d5d63a426c19.png)","qrcodeImageUrl":"","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","category":"分类","postTime":"发布时间","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","commentOnGithub":"添加评论 (by Github Issues)"},"markedEndingWordsExtra":"<p><strong>感谢你的阅读。欢迎通过微信（扫描下方二维码）或<a href=\"https://github.com/Terry-Su/blogs-cn\">Github</a>订阅我的博客。</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/23733477/77869172-2459f400-7270-11ea-8a84-d5d63a426c19.png\" alt=\"微信公众号:苏溪云的博客\" /></p>"}
