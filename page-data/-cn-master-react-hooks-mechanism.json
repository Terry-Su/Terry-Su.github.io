{"pathnameRoot":"/cn/","authorUrl":"https://github.com/Terry-Su","locale":"zh_CN","logoTitle":"苏溪云","noteIsAutoTranslated":"本文为自动翻译。","copyright":{"left":"版权 © 2017-","center":"苏溪云","right":"保留所有权利"},"blogGithub":"https://github.com/Terry-Su/blogs-cn","id":"cn/master-react-hooks-mechanism","title":"轻松掌握React Hooks底层实现原理","path":"Technology/FrontEnd/React","route":"/cn/master-react-hooks-mechanism","text":"\n\nconst layoutProps = {\n  \n};\nclass MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><MDXTag name=\"p\" components={components}>{`由于最近业务较忙，2020年搞懂React原理系列文章最终篇直到现在才在业余时间抽空完成。之前在公司内部已有过一次PPT形式的分享，但经过一段时间对hooks的深度使用，对其又有了更深一些了解，故本次加上新内容并以文章形式再分享一次。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`持续一年阅读React源码和总结其核心原理，慢慢也有了一些心得：`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`读懂源码只是第一步，弄懂其功能的代码实现方式。而再进一步是彻底搞懂其实现原理、思想，它通过什么方式实现了什么功能，带来了什么价值。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`不管它的底层代码如何改写，最终的目的都是为了实现某个功能。只要我们把其功能实现原理掌握，便可活学活用，结合业务让业务开发效率更高，或围绕业务做一些生产力工具。`}</MDXTag>\n<MDXTag name=\"blockquote\" components={components}>\n<MDXTag name=\"p\" components={components} parentName=\"blockquote\">{`React使用当前最新版本：`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`17.0.1`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components} parentName=\"blockquote\">{`今年写了一个“搞懂React源码系列”，把React最核心的内容用最易懂的方式讲清楚。2020年搞懂React源码系列：`}</MDXTag>\n<MDXTag name=\"ul\" components={components} parentName=\"blockquote\">\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://terry-su.github.io/cn/understand-react-diff-algorithm-from-source-codes\"}}>{`React Diff原理`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://terry-su.github.io/cn/undestand-react-scheduling-mechanism-from-source-code-concurrent-mode\"}}>{`React 调度原理`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\"><MDXTag name=\"a\" components={components} parentName=\"li\" props={{\"href\":\"https://terry-su.github.io/cn/debug-react-source-code-using-special-method\"}}>{`搭建阅读React源码环境-支持React所有版本断点调试细分文件`}</MDXTag></MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`（当前）React Hooks原理`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components} parentName=\"blockquote\">{`少了React Fiber更新原理？那是因为`}<MDXTag name=\"a\" components={components} parentName=\"p\" props={{\"href\":\"https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e\"}}>{`国外大佬的一篇文章`}</MDXTag>{`写得太好，没有必要再重复写一次。或许明年可以找个时间写个简明概要的React所有原理汇总文章。`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`本文将重点讲`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`useMemo`}</MDXTag>{`、`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`useEffect`}</MDXTag>{`和`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`useState`}</MDXTag>{`3个api，因为它们在日常开发中最常用。后面讲其他几个api。本次主要描述每个hook的功能和原理。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`基础知识`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`任何一个hook的调用方式都是：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`输出 = hook函数(输入)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`一定会有输入和hook函数和输出。\n而被调用的过程一般是2种：组件初始化和组件更新。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`UseMemo实现原理`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`useMemo的功能是记忆某个结果，只有依赖项发生改变时才更新输出结果。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`输出结果 = useMemo(计算函数，依赖项)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`下方展示其在不同过程中useMemo内部实现原理。`}</MDXTag>\n<MDXTag name=\"table\" components={components}>\n<MDXTag name=\"thead\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"thead\">\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`输入`}</MDXTag>\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`hook函数`}</MDXTag>\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`输出`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"tbody\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"tbody\">\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`计算函数，依赖项`}</MDXTag>\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`useMemo`}</MDXTag>\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`计算结果`}</MDXTag>\n</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件初始化`}</MDXTag>{`：\n1. 执行计算函数，获取计算结果\n2. 缓存结果结果和依赖项\n3. 返回计算结果`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件更新`}</MDXTag>{`:`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`if (依赖项和已缓存依赖项相同) {\n    返回已缓存计算结果\n} else {\n    执行计算函数，获取新计算结果\n    缓存新计算结果和新依赖项\n    返回新计算结果\n}\n`}</MDXTag></MDXTag>\n<MDXTag name=\"blockquote\" components={components}>\n<MDXTag name=\"p\" components={components} parentName=\"blockquote\">{`其中一个问题值得注意，依赖项是如何比较的？深比较或浅比较？因为依赖项一般是一个数组，而数组中的每个元素是具体的依赖变量，那么React是如何比较的？`}</MDXTag>\n<MDXTag name=\"p\" components={components} parentName=\"blockquote\">{`翻看源码，发现若两个依赖项都是数组，则React会使用Object.is对其每一个元素进行强比较。`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`Object.is('foo', 'foo');     // true\nObject.is(window, window);   // true\n\nObject.is('foo', 'bar');     // false\nObject.is([], []);           // false\n\nvar foo = { a: 1 };\nvar bar = { a: 1 };\nObject.is(foo, foo);         // true\nObject.is(foo, bar);         // false\n\nObject.is(null, null);       // true\n\n// Special Cases\nObject.is(0, -0);            // false\nObject.is(-0, -0);           // true\nObject.is(NaN, 0/0);         // true\n`}</MDXTag></MDXTag>\n<MDXTag name=\"blockquote\" components={components}>\n<MDXTag name=\"p\" components={components} parentName=\"blockquote\">{`转念一想，其实就应这样比较。`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`UseEffect实现原理`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`useEffect(创建函数，依赖项)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`useEffect的主要功能是：`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`组件加载后执行创建函数，创建函数执行后会返回一个销毁函数，在组件销毁前执行。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`若依赖项为数组且不为空，则依赖项改变时，会执行上一个销毁函数和重新创建函数。`}</MDXTag>\n<MDXTag name=\"table\" components={components}>\n<MDXTag name=\"thead\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"thead\">\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`输入`}</MDXTag>\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`hook函数`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"tbody\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"tbody\">\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`创建函数，依赖项`}</MDXTag>\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`useEffect`}</MDXTag>\n</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`useEffect直接被调用的过程是组件初始化和组件更新，其销毁函数被调用的过程是组件销毁。`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件初始化`}</MDXTag>{`：\n1. 生成一个effect对象，包含创建函数\n2. 缓存effect和依赖项\n3. 当React进入提交阶段，执行effect中的创建函数，获取销毁函数。若销毁函数不为空，则将其放入effect。`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件更新`}</MDXTag>{`：\n1. 生成一个effect对象, 包含创建函数\n2. 检查已缓存effect中是否有销毁函数，有的话则放入新effect对象\n3. 缓存effect\n4. 若依赖项和已缓存依赖项不同，则将hasEffect标记添加到effect，并缓存新依赖项\n5. 当React进入提交阶段：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`if (effect有hasEffect标记) {\n    若effect中有销毁函数，则先执行销毁函数\n    执行effect中的创建函数，获取销毁函数。若销毁函数不为空，则将其放入effect\n} \n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件销毁`}</MDXTag>{`：\n1. 若effect中有销毁函数，则执行。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`UseState实现原理`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`useState的功能是设置一个状态的初始值，并返回当前状态和设置状态的函数。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`[状态，设置状态函数] = useState(初始状态)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"table\" components={components}>\n<MDXTag name=\"thead\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"thead\">\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`输入`}</MDXTag>\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`hook函数`}</MDXTag>\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`输出`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"tbody\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"tbody\">\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`初始状态`}</MDXTag>\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`useState`}</MDXTag>\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`状态，设置状态函数`}</MDXTag>\n</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`useState直接被调用的过程也是组件初始化和组件更新，其还有一个调用设置状态函数的过程。`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件初始化`}</MDXTag>{`：\n1. 若初始状态为函数，则将函数执行结果设为当前状态。否则将初始状态设为当前状态。\n2. 生成设置状态函数\n3. 缓存当前状态和设置状态函数\n4. 返回当前状态`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件更新`}</MDXTag>{`：\n1. 读取缓存状态和设置状态函数\n2. 返回缓存状态`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`执行设置状态函数`}</MDXTag>{`：\n1. 更新缓存状态\n2. 触发React组件树更新\n3. 在下一次组件更新时，将返回已被更新的缓存状态`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`useReducer`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`useReducer的功能和原理与useState一致，区别在于useReducer使用函数管理状态，使用派发动作指令函数作为设置状态函数。Reducer概念可参看redux。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`[状态，派发动作指令函数]=useReducer(reducer函数，初始状态)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"h2\" components={components}>{`UseCallback实现原理`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`已缓存函数 = useCallback(待缓存函数，依赖项)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`useCallback的功能就是useMemo记忆函数一个封装，相比useMemo只是少套了一层函数：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`已缓存函数 = useMemo( () => 待缓存函数, 依赖项)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`不过React内部并没有用useMemo直接实现useCallback，而是用一套类似useMemo的代码实现。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`UseRef实现原理`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`{current: 当前值} = useRef(初始当前值)\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`useRef的功能是生成一个对象，结构是：`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`{current: 当前值}`}</MDXTag>{`, 对象一旦初始化，不会因为组件更新而改变。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`虽然对象初始化后不会因组件更新改变，但我们可以通过更改其current属性，当前值就相当于一个组件的变量，类似class组件的实例属性。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`useRef最常用的场景莫过于设置组件的ref。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-jsx\"}}>{`const container = useRef(null)\nreturn <div ref={container}></div>\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`其实此处官网也有特别讲，div上的ref属性将触发设置`}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`container.current`}</MDXTag>{`为dom对象。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`但我们也可以把useRef作为生成组件变量的方法灵活应用。`}</MDXTag>\n<MDXTag name=\"table\" components={components}>\n<MDXTag name=\"thead\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"thead\">\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`输入`}</MDXTag>\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`hook函数`}</MDXTag>\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`输出`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"tbody\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"tbody\">\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`初始当前值`}</MDXTag>\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`useRef`}</MDXTag>\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`{current: 当前值}`}</MDXTag>\n</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件初始化`}</MDXTag>{`：\n1. 生成对象: { current: 初始当前值 }\n2. 缓存对象\n3. 返回缓存对象`}</MDXTag>\n<MDXTag name=\"p\" components={components}><MDXTag name=\"strong\" components={components} parentName=\"p\">{`组件更新`}</MDXTag>{`：\n1. 获取缓存对象\n2. 返回缓存对象`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`UseImperativeHandle`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`useImperativeHandle的功能被子组件使用，实现父组件调用子组件内部方法，一般与forwardRef一起使用。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`UseImperativeHandle实现原理与useEffect类似。`}</MDXTag>\n<MDXTag name=\"h2\" components={components}>{`UseLayoutEffect`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`useLayoutEffect和useLayout的功能区别：`}</MDXTag>\n<MDXTag name=\"table\" components={components}>\n<MDXTag name=\"thead\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"thead\">\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`useLayoutEffect`}</MDXTag>\n<MDXTag name=\"th\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`useLayout`}</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"tbody\" components={components} parentName=\"table\">\n<MDXTag name=\"tr\" components={components} parentName=\"tbody\">\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`渲染到屏幕前执行`}</MDXTag>\n<MDXTag name=\"td\" components={components} parentName=\"tr\" props={{\"align\":null}}>{`渲染到屏幕后执行`}</MDXTag>\n</MDXTag>\n</MDXTag>\n</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{\"className\":\"language-js\"}}>{`useLayoutEffect(() => {\n   // 组件初始化或更新在渲染到屏幕前执行\n   return () => {\n     // 1. 组件卸载前执行 2. 执行下一个effect前执行\n   } \n}, )\n`}</MDXTag></MDXTag>\n<MDXTag name=\"hr\" components={components}></MDXTag>\n<MDXTag name=\"p\" components={components}>{`在跨年前完成2020搞懂React原理系列文章最后一篇，也是为了迎接即将到来的2021。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在2021年，新的系列即将启航。不过在写新系列前，下一篇将先写微前端框架实现原理。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`祝大家新年快乐！`}</MDXTag>\n           </MDXTag>\n  }\n}\nMDXContent.isMDXComponent = true\nrender( <MDXContent /> )\n  ","postTime":1609430100000,"comment":13,"isAutoTranslated":false,"availableOtherLocales":[],"importedCodes":"","siteTitle":"轻松掌握React Hooks底层实现原理(苏溪云的博客)","siteMetaDescription":" 轻松掌握React Hooks底层实现原理 由于最近业务较忙，2020年搞懂React原理系列文章最终篇直到现在才在业余时间抽空完成。之前在公司内部已有过一次PPT形式的分享，但经过一段时间对hooks的深度使用，对其又有了更深一些了解，故本次... (苏溪云的博客)","categoryTitle":"分类","postTimeTitle":"发布时间","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","endingWords":"article.endingWords","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","remarkDisqusComment":"https://terrysu.disqus.com/embed.js","texts":{"siteTitle":"苏溪云的博客","siteMetaDescription":"苏溪云的原创前端技术博客 4年前端 分享主流前端技术 JavaScript ReactJS","categoryNewest":"最近发布","navArticles":"所有文章","navAbout":"关于作者"},"articleTexts":{"endingWordsExtra":"**感谢你的阅读。欢迎通过微信（扫描下方二维码）或[Github](https://github.com/Terry-Su/blogs-cn)订阅我的博客。**\n\n ![微信公众号:苏溪云的博客](https://user-images.githubusercontent.com/23733477/77869172-2459f400-7270-11ea-8a84-d5d63a426c19.png)","qrcodeImageUrl":"","reprintingNote":"作者版权所有，转载请注明出处，禁止商业转载","category":"分类","postTime":"发布时间","githubIssuePageBase":"https://github.com/Terry-Su/blogs-cn/issues/","githubCommentBase":"https://api.github.com/repos/terry-su/blogs-cn/issues/","commentOnGithub":"添加评论 (by Github Issues)"},"markedEndingWordsExtra":"<p><strong>感谢你的阅读。欢迎通过微信（扫描下方二维码）或<a href=\"https://github.com/Terry-Su/blogs-cn\">Github</a>订阅我的博客。</strong></p>\n<p><img src=\"https://user-images.githubusercontent.com/23733477/77869172-2459f400-7270-11ea-8a84-d5d63a426c19.png\" alt=\"微信公众号:苏溪云的博客\" /></p>"}
